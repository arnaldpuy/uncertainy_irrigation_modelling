---
title: "Fifty years of research have deepened uncertainties in global irrigation water use"
subtitle: "R code of the multiverse analysis"
author: "Arnald Puy"
header-includes:
  - \usepackage[font=footnotesize]{caption}
  - \usepackage{dirtytalk}
  - \usepackage{booktabs}
  - \usepackage{tabulary}
  - \usepackage{enumitem}
  - \usepackage{lmodern}
  - \usepackage{amsmath}
  - \usepackage{mathtools}
  - \usepackage[T1]{fontenc}
  - \usepackage{tikz}
output:
  pdf_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 2
    keep_tex: true
  word_document:
    toc: no
    toc_depth: '2'
  html_document:
    keep_md: true
link-citations: yes
fontsize: 11pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dev = "pdf", cache = TRUE)
```

\newpage

# Preliminary functions

```{r, warning=FALSE, message=FALSE}

#   PRELIMINARY FUNCTIONS ######################################################

sensobol::load_packages(c("openxlsx", "data.table", "tidyverse","cowplot", 
                          "benchmarkme", "parallel", "wesanderson", "scales", "ncdf4", 
                          "countrycode", "rworldmap", "sp", "doParallel", "here", "lme4", 
                          "microbenchmark", "mgcv", "brms", "randomForest", "here", 
                          "igraph", "ggraph", "gganimate", "magick", 
                          "randomForestExplainer", "ggrepel"))

# Create custom theme -----------------------------------------------------------

theme_AP <- function() {
  theme_bw() +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          legend.background = element_rect(fill = "transparent",
                                           color = NA),
          legend.key = element_rect(fill = "transparent",
                                    color = NA), 
          strip.background = element_rect(fill = "white"), 
          legend.text = element_text(size = 7.3), 
          axis.title = element_text(size = 10),
          legend.key.width = unit(0.4, "cm"), 
          legend.key.height = unit(0.4, "cm"), 
          legend.key.spacing.y = unit(0, "lines"),
          legend.box.spacing = unit(0, "pt"),
          legend.title = element_text(size = 7.3), 
          axis.text.x = element_text(size = 7), 
          axis.text.y = element_text(size = 7), 
          axis.title.x = element_text(size = 7.3), 
          axis.title.y = element_text(size = 7.3),
          plot.title = element_text(size = 8),
          strip.text.x = element_text(size = 7.4), 
          strip.text.y = element_text(size = 7.4)) 
}

# Select color palette ----------------------------------------------------------

selected.palette <- "Darjeeling1"
```

```{r source_functions, warning=FALSE, message=FALSE, results="hide"}

# SOURCE ALL R FUNCTIONS NEEDED FOR THE STUDY ###################################

# Source all .R files in the "functions" folder --------------------------------

r_functions <- list.files(path = here("functions"), pattern = "\\.R$", full.names = TRUE)
lapply(r_functions, source)

```

# The Multiverse Analysis

## The dataset

```{r naomi_data}

# LOAD THE DATASET #############################################################

iww_dataset <- fread("./dataset/iww_dataset.csv")
```

```{r naomi_features, dependson="naomi_data", fig.height=1.8, fig.width=2}

# FEATURES OF THE DATASET ######################################################

# Definition of target years ---------------------------------------------------

target_year <- c(2000, 2010, 2050, 2070, 2100)

# Name of different studies ----------------------------------------------------

sort(unique(iww_dataset[, title]))

# Number of data points --------------------------------------------------------

nrow(iww_dataset)

# Number of different studies per variable ---------------------------------------

iww_dataset[, unique(title), variable] %>%
  .[, .N, variable]

# Number of data points for each target year -----------------------------------

iww_dataset[estimation.year %in% target_year, .N, estimation.year]

# Number of unique studies estimating for each target year ---------------------

iww_dataset[estimation.year %in% target_year, unique(title), estimation.year] %>%
  .[, .N, estimation.year]

# Number of data points for every targeted year --------------------------------

iww_dataset[, .N, estimation.year] %>%
  .[order(estimation.year)]

# Number of data points for year 2000 or later years ---------------------------

iww_dataset[, .N, estimation.year] %>%
  .[estimation.year >= 2000] %>%
  .[, N] %>%
  sum(.)

# Cumulative sum of published studies ------------------------------------------

cumulative.iww <- iww_dataset[, .(title, publication.date, variable)] %>%
  .[!duplicated(.)] %>%
  setorder(., publication.date) %>%
  .[, .N, publication.date] %>%
  .[, cumulative_sum := cumsum(N)] %>%
  ggplot(., aes(publication.date, cumulative_sum)) +
  geom_line() + 
  scale_x_continuous(breaks = breaks_pretty(n = 3)) +
  geom_point(size = 0.7) + 
  theme_AP() + 
  labs(x = "Publication year", y = "Nº studies")

cumulative.iww
```

```{r histogram_data_points, dependson="naomi_data", fig.height=2, fig.width=2}

# DISTRIBUTION OF DATA POINTS THROUGH YEARS @####################################

plot.bar <- iww_dataset[, .N, estimation.year] %>%
  ggplot(., aes(estimation.year, N)) +
  geom_bar(stat = "identity") +
  scale_x_continuous(breaks = breaks_pretty(n = 3)) +
  labs(x = "Target year of estimation", y = "Nº estimations") +
  theme_AP()

plot.bar
```

```{r plot_naomi, dependson="naomi_data", fig.height=3.5, fig.width=6}

# PLOT ALL ESTIMATIONS ##########################################################

def.alpha <- 0.2

plot.iww <- iww_dataset %>%
  .[, .(author, study, estimation.year, value)] %>%
  na.omit() %>%
  ggplot(., aes(estimation.year, value, color = author, group = study)) +
  geom_point(alpha = def.alpha, size = 0.5) +
  labs(x = "Estimation year", y = bquote("Km"^3)) +
  scale_color_discrete(name = "") +
  geom_line(alpha = def.alpha) +
  theme_AP() +
  guides(color = guide_legend(ncol = 2)) +
  theme(legend.text = element_text(size = 5.2), 
        legend.key.width = unit(0.25, "cm"), 
          legend.key.height = unit(0.25, "cm"))

plot.iww
```

```{r plot_animation, dependson="plot_naomi", eval=FALSE, echo=FALSE}

animated_plot <- iww_dataset %>%
  .[, .(author, study, estimation.year, value, publication.date)] %>%
  na.omit() %>%
  ggplot(., aes(estimation.year, value, color = author, group = study)) +
  geom_point(size = 0.5) +
  labs(x = "Estimation year", y = bquote("Km"^3)) +
  scale_color_discrete(name = "") +
  geom_line(alpha = def.alpha) +
  theme_AP() +
  guides(color = guide_legend(ncol = 2)) +
  theme(legend.text = element_text(size = 5.5), 
        legend.key.width = unit(0.25, "cm"), 
        legend.key.height = unit(0.25, "cm")) +
  ggtitle("Publication Year: {frame_along}") +
  transition_reveal(publication.date)

animation <- animate(animated_plot, 
                     nframes = 200, 
                     fps = 10, 
                     duration = 20, 
                     renderer = magick_renderer())

animation <- animate(animated_plot, nframes=70, width = 800, height = 600, 
                     res = 150, renderer = magick_renderer())

image_write_gif(animation, 'animation.gif')
```

```{r plot.models, dependson="naomi_features", fig.height=4, fig.width=3}
 
# PLOT NUMBER OF UNIQUE STUDIES PER MODEL ######################################

plot.models <- iww_dataset %>%
  .[, .(title, doi, model)] %>%
  .[, model:= tolower(model)] %>%
  .[, unique(doi), model] %>%
  .[, model := gsub("(?i)watergap\\s*\\d*\\.?\\d*", "watergap", model, perl = TRUE)] %>%
  .[, .N, model]  %>%
  .[, model:= ifelse(is.na(model), "No info", model)] %>%
  ggplot(., aes(reorder(model, N), N)) +
  geom_bar(stat = "identity") + 
  labs(x = "", y = "Nº studies") +
  coord_flip() +
  scale_y_continuous(breaks = breaks_pretty()) +
  theme_AP() + 
  theme(axis.text.y = element_text(size = 5.5))

plot.models
```

## Graphical representation of the multiverse

```{r plot_examples, fig.height=3, fig.width=1.5}

# PLOT EXAMPLES TO ILLUSTRATE APPROACH #########################################

# Set seed for reproducibility -------------------------------------------------

set.seed(123)

# Create datasets for different SD trends --------------------------------------

data_increasing <- data.frame(
  period = rep(c("1990-2000", "2000-2010", "2010-2020"), times = c(5, 7, 4)),  
  value = c(rnorm(5, mean = 5, sd = 0.3),  # Low SD
            rnorm(7, mean = 7, sd = 0.8),  # Medium SD
            rnorm(4, mean = 6, sd = 1.5)),  # High SD
  target_year = 2000
)

data_decreasing <- data.frame(
  period = rep(c("1980-2000", "2000-2020"), times = c(5, 7)),  
  value = c(rnorm(5, mean = 5, sd = 1.5),  # High SD
            rnorm(7, mean = 7, sd = 0.8)), # Medium
  target_year = 2010
)

data_invertedV <- data.frame(
  period = rep(c("1990-2000", "2000-2010", "2010-2020"), times = c(5, 7, 4)),  
  value = c(rnorm(5, mean = 5, sd = 0.4),  # Low SD
            rnorm(7, mean = 7, sd = 1.4),  # High SD (peak in the middle)
            rnorm(4, mean = 5, sd = 0.4)),  # Low SD again
  target_year = 2070
)

# Function to compute SD and create a ggplot -----------------------------------

create_plot <- function(data, title) {
  sd_values <- data %>%
    group_by(period) %>%
    summarize(sd_value = sd(value) + 3)
  
  ggplot(data, aes(x = period, y = value)) +
    geom_point(size = 1) +
    geom_point(data = sd_values, aes(x = period, y = sd_value), color = "red", size = 1.5) +  # SD as red dots
    geom_line(data = sd_values, aes(x = period, y = sd_value, group = 1), color = "red", linewidth = 1) +  # Line connecting SD values
    theme_AP() +
    theme(axis.text.x = element_text(size = 5.35), 
          plot.margin = unit(c(0.1, 0.1, 0, 0.1), "cm")) +
    scale_y_continuous(breaks = breaks_pretty(n = 3)) +
    scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
    labs(x = "", y = "Value") +
    annotate("text", x = 0.1 + 0.5, y = max(data$value), 
             label = unique(data$target_year), hjust = 0, vjust = 1, 
             size = 2)
}


# Generate the three plots -----------------------------------------------------

p1 <- create_plot(data_increasing) 
p2 <- create_plot(data_decreasing)
p3 <- create_plot(data_invertedV)

# Merge using plot_grid --------------------------------------------------------

plot.examples.trends.data <- plot_grid(p1, p2, p3, ncol = 1, labels = c("e", "", ""))
plot.examples.trends.data
```

```{r plotting_forks}

# GRAPHICAL REPRESENTATION OF THE GARDEN OF FORKING PATHS ######################

# Define size of nodes ---------------------------------------------------------

size.nodes <- 1.5

# Create a balanced binary tree with height 3 ----------------------------------

tree <- make_tree(15, children = 2, mode = "out")

# Create a tree plot with all edges highlighted in red -------------------------

all.paths <- ggraph(tree, layout = "dendrogram") +
  geom_edge_link(color = "red", width = 1) +
  geom_node_point(size = size.nodes, color = "red") +
  theme_AP() +
  labs(x = "", y = "") +
  theme(legend.position = "none", 
        axis.ticks = element_blank(), 
        axis.text.x = element_blank(), 
        axis.text.y = element_blank())

all.paths

# Create a tree plot with only one analytical path highlighted -----------------

# Define the path to highlight (from root to a specific node) ------------------

highlight_nodes <- c(1, 2, 5, 11)  # Path: 1 → 2 → 5 → 11

highlight_edges <- apply(cbind(head(highlight_nodes, -1), 
                               tail(highlight_nodes, -1)), 1, function(x) 
                                 paste(x, collapse = "-"))

# Assign default colors (black) to all edges and nodes -------------------------

E(tree)$edge_color <- "black"
V(tree)$node_color <- "black"

# Extract edges from the tree and match with highlight_edges -------------------

edge_list <- apply(get.edgelist(tree), 1, function(x) paste(x, collapse = "-"))
E(tree)$edge_color[edge_list %in% highlight_edges] <- "red"

# Highlight the selected nodes in red -___--------------------------------------

V(tree)$node_color[highlight_nodes] <- "red"

# Plot the tree with explicitly defined colors for both edges and nodes --------

one.path <- ggraph(tree, layout = "dendrogram") +
  geom_edge_link(aes(edge_color = edge_color), width = 1) +  # Correct edge colors
  geom_node_point(aes(color = node_color), size = size.nodes) +  # Correct node colors
  scale_edge_color_manual(values = c("black" = "black", "red" = "red")) +  # Fix for edges
  scale_color_manual(values = c("black" = "black", "red" = "red")) +  # Fix for nodes
  theme_AP() + 
  labs(x = "", y = "") +
  theme(legend.position = "none", 
        axis.ticks = element_blank(), 
        axis.text.x = element_blank(), 
        axis.text.y = element_blank())

one.path
```

```{r plot_forking_paths, dependson="plotting_forks", fig.height=1.5, fig.width=3}

# MERGE FORKING PATHS ##########################################################

plot_grid(one.path, all.paths, ncol = 2, labels = c("a", ""))
```

```{r plotting_forks2}

# GRAPHICAL REPRESENTATION OF THE GARDEN OF FORKING PATHS #######################

# Define size of nodes ---------------------------------------------------------

size.nodes <- 1.5

# Create a balanced binary tree with height 3 ----------------------------------

tree <- make_tree(15, children = 2, mode = "out")

# Create a tree plot with all edges highlighted in red -------------------------

all.paths <- ggraph(tree, layout = "dendrogram") +
  geom_edge_link(color = "red", width = 1) +
  geom_node_point(size = size.nodes, color = "red") +
  theme_AP() +
  labs(x = "", y = "") +
  theme(legend.position = "none", 
        axis.ticks = element_blank(), 
        axis.text.x = element_blank(), 
        axis.text.y = element_blank())

all.paths

# Create a tree plot with only one analytical path highlighted -----------------

# Define the path to highlight (from root to a specific node) ------------------

highlight_nodes <- c(1, 2, 4, 8)  # Path: 1 → 2 → 5 → 11

highlight_edges <- apply(cbind(head(highlight_nodes, -1), 
                               tail(highlight_nodes, -1)), 1, function(x) 
                                 paste(x, collapse = "-"))

# Assign default colors (black) to all edges and nodes -------------------------

E(tree)$edge_color <- "black"
V(tree)$node_color <- "black"

# Extract edges from the tree and match with highlight_edges -------------------

edge_list <- apply(get.edgelist(tree), 1, function(x) paste(x, collapse = "-"))
E(tree)$edge_color[edge_list %in% highlight_edges] <- "red"

# Highlight the selected nodes in red -___--------------------------------------

V(tree)$node_color[highlight_nodes] <- "red"

# Plot the tree with explicitly defined colors for both edges and nodes --------

one.path2 <- ggraph(tree, layout = "dendrogram") +
  geom_edge_link(aes(edge_color = edge_color), width = 1) +  # Correct edge colors
  geom_node_point(aes(color = node_color), size = size.nodes) +  # Correct node colors
  scale_edge_color_manual(values = c("black" = "black", "red" = "red")) +  # Fix for edges
  scale_color_manual(values = c("black" = "black", "red" = "red")) +  # Fix for nodes
  theme_AP() + 
  labs(x = "", y = "") +
  theme(legend.position = "none", 
        axis.ticks = element_blank(), 
        axis.text.x = element_blank(), 
        axis.text.y = element_blank())

one.path2
```

```{r plot_forking_paths2, dependson="plotting_forks2", fig.height=1.5, fig.width=3}

# MERGE FORKING PATHS ##########################################################

plot_grid(one.path, all.paths, ncol = 2, labels = c("a", ""))
```

## The garden of forking paths

```{r forking_paths, dependson=c("naomi_data", "naomi_features")}

# DEFINE THE UNCERTAINTY SPACE #################################################

# Target year ------------------------------------------------------------------

## Defined above

# Target year interval ---------------------------------------------------------

target_year_interval <- c("yes", "no")

# Interval publication ---------------------------------------------------------

interval <- c(10, 15, 20)

# Metrics of study -------------------------------------------------------------

metrics <- c("cv", "range", "sd", "var", "entropy", "iqr")

# Rolling windows --------------------------------------------------------------

rolling_window_factor <- c(1, 0.5)

# Define the forking paths -----------------------------------------------------

forking_paths <- expand.grid(target_year = target_year,
                             target_year_interval = target_year_interval,
                             interval = interval,
                             rolling_window_factor = rolling_window_factor,
                             metric = metrics) %>%
  data.table()

# Number of simulations --------------------------------------------------------

nrow(forking_paths)

# RUN MODEL ####################################################################

# Run simulations --------------------------------------------------------------

trend <- list()

for (i in 1:nrow(forking_paths)) {
  
  trend[[i]] <- forking_paths_fun(dt = iww_dataset,
                                  target_year = forking_paths[[i, "target_year"]], 
                                  target_year_interval = forking_paths[[i, "target_year_interval"]],
                                  interval = forking_paths[[i, "interval"]], 
                                  rolling_window_factor = forking_paths[[i, "rolling_window_factor"]],
                                  metric = forking_paths[[i, "metric"]])
}
```

```{r naomi_arrange, dependson="forking_paths"}

# ARRANGE DATA #################################################################

output.dt <- lapply(trend, function(x) x[["results"]]) %>%
  do.call(rbind, .) %>%
  data.table() %>%
  setnames(., "V1", "trend") %>%
  .[, row:= .I]

final.dt <- cbind(forking_paths, output.dt)

# ARRANGE DATA PRIMARY #########################################################

data.dt <- lapply(trend, function(x) x[["data"]]) %>%
  rbindlist(., idcol = "row") %>%
  merge(., final.dt, by = "row")

# Export simulations -----------------------------------------------------------

fwrite(final.dt, "forking.paths.dataset.csv")
write.xlsx(final.dt, "forking.paths.dataset.xlsx")
fwrite(data.dt, "data.dt.csv")

# Print the fraction of simulations in each classification ---------------------

final.dt %>%
  .[, .(total = .N), trend] %>%
  .[, fraction:= total / nrow(output.dt)] %>%
  print()


# Now remove all simulations that produced just one single point ---------------

final.dt <- final.dt[!trend == "single point"]

# Calculate how many forking paths lead to different results just
# by changing the metric (all the rest fixed) ----------------------------------

final.dt %>%
  .[, .(target_year, target_year_interval, interval, 
        rolling_window_factor, metric, trend)] %>%
  .[order(target_year, target_year_interval, interval, rolling_window_factor)] %>%
  split(., ceiling(seq_len(nrow(.)) / length(metrics))) %>%
  rbindlist(., idcol = "group") %>%
  .[, .(unique_trend_count = uniqueN(trend)), group] %>%
  .[, .N, unique_trend_count] %>%
  .[order(unique_trend_count)]

# Simulations that did not lead to a reduction in uncertainty ------------------

final.dt %>%
  .[, .(total = .N), trend] %>%
  .[, fraction:= total / nrow(output.dt)] %>%
  .[!trend == "Decrease"] %>%
  .[, sum(fraction)]
```

```{r examples_plots, dependson="forking_paths", fig.height=3.5, fig.width=5.5, warning=FALSE}

# PLOTS FORKING PATHS EXAMPLES ##################################################

plots.dt <- lapply(trend, function(x) x[["plot"]]) 

# Increasing trends ------------------------------------------------------------

plots.increasing <- plot_grid(plots.dt[[7]] + 
                                geom_line(color = "red", group = 1), 
                              plots.dt[[11]] + 
                                geom_line(color = "red", group = 1), 
                              plots.dt[[278]] +
                                geom_line(color = "red", group = 1), 
                              plots.dt[[226]] + 
                                geom_line(color = "red", group = 1), ncol = 1)

# Decreasing trend ------------------------------------------------------------

plots.decreasing <- plot_grid(plots.dt[[4]] + 
                                geom_line(color = "darkgreen", group = 1) +
                                geom_point(color = "darkgreen"), 
                              plots.dt[[69]] + 
                                geom_line(color = "darkgreen", group = 1) +
                                geom_point(color = "darkgreen"), 
                              plots.dt[[100]] + 
                                geom_line(color = "darkgreen", group = 1) +
                                geom_point(color = "darkgreen"), 
                              plots.dt[[142]] + 
                                geom_line(color = "darkgreen", group = 1) +
                                geom_point(color = "darkgreen"), ncol = 1)

# Random trend -----------------------------------------------------------------

plots.random <- plot_grid(plots.dt[[1]] + 
                            geom_line(color = "orange", group = 1) +
                            geom_point(color = "orange"), 
                          plots.dt[[3]] + 
                            geom_line(color = "orange", group = 1) +
                            geom_point(color = "orange"), 
                          plots.dt[[33]] + 
                            geom_line(color = "orange", group = 1) +
                            geom_point(color = "orange"), 
                          plots.dt[[340]] + 
                            geom_line(color = "orange", group = 1) +
                            geom_point(color = "orange"), ncol = 1)
# Merge ------------------------------------------------------------------------

plots.examples.trends <- plot_grid(plots.increasing, plots.decreasing, 
                                   plots.random, ncol = 3)

plots.examples.trends
```

```{r plot_results_forking_paths, dependson=c("naomi_arrange", "forking_paths"), fig.height=2.2, fig.width=3}

# PLOT RESULTS #################################################################

selected_colors <- c("Increase" = "red", "Decrease" = "darkgreen", "Unstable" = "orange")

plot.fraction <- final.dt[, .(total = .N), trend] %>%
  .[, fraction:= total / nrow(output.dt)] %>%
  ggplot(., aes(trend, fraction, fill = trend)) +
  geom_bar(stat = "identity") +
  labs(x = "", y = "Fraction") +
  scale_fill_manual(values = selected_colors, name = "Uncertainty") +
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  theme_AP() + 
  theme(axis.ticks.x = element_blank(), 
        axis.text.x = element_blank(), 
        legend.position = "right")

plot.fraction 
```

## Directional analysis

```{r directional_analysis, dependson="forking_paths", fig.height=1.6, fig.width=4.5}

# CHECK DIRECTIONAL TRENDS BETWEEN UNCERTAINTY AND NUMBER OF STUDIES, ESTIMATES
# AND MODELS ###################################################################

data_aggregated <- lapply(trend, function(x) x[["data_aggregated"]])

# Apply function --------------------------------------------------------------

directional_results <- rbindlist(
  
  lapply(seq_along(data_aggregated), function(i) {
    
    directional_trends_fun(data_aggregated[[i]], dataset_id = paste0("dataset_", i))
  }),
  
  fill = TRUE
)

# Summary ----------------------------------------------------------------------

directional_results[, .(avg_agreement_studies = mean(studies, na.rm = TRUE),
                        avg_agreement_estimates = mean(estimates, na.rm = TRUE),
                        avg_agreement_models = mean(models, na.rm = TRUE))]

# Plot -------------------------------------------------------------------------

directional_results %>%
  melt(., measure.vars = c("studies", "estimates", "models")) %>%
  .[, variable:= paste("Nº", variable, sep = " ")] %>%
  ggplot(., aes(value)) +
  geom_histogram() +
  facet_wrap(~variable) +
  theme_AP() +
  labs(x = "Percentage of agreement with the uncertainty trend", y = "Nº paths")
```

## Random forest model

```{r random_forest, dependson=c("naomi_arrange", "forking_paths"), fig.width=3.5, fig.height=2}

# RANDOM FOREST #################################################################

# Convert categorical variables to factors -------------------------------------

df <- data.frame(final.dt[trend != "single point"]) # Remove 5% observations
df$metric <- as.factor(df$metric)
df$trend <- as.factor(df$trend)
df$target_year_interval <- as.factor(df$target_year_interval)

# Train the model with weights on 2,000 random trees ----------------------------

rf_model <- randomForest(trend ~ target_year + target_year_interval + interval + 
                           rolling_window_factor + metric, 
                         data = df, importance = TRUE, ntree = 5000, 
                         classwt = c(1.5, 1.5, 1), mtry = 3)

# Check model summary ----------------------------------------------------------

print(rf_model)

# View variable importance -----------------------------------------------------

dt_rf_model <- data.frame(importance(rf_model))
dt_rf_model

# Compute importance -----------------------------------------------------------

importance_frame <- measure_importance(rf_model)
data <- importance_frame[importance_frame$no_of_trees > 0, ]

# Retrieve data ----------------------------------------------------------------

data_for_labels <- importance_frame[importance_frame$variable %in% 
                                      important_variables(importance_frame, k = 10, 
                                                          measures = c("mean_min_depth", 
                                                                       "times_a_root", 
                                                                       "no_of_nodes")),]

data_for_labels

# Plot -------------------------------------------------------------------------

plot.rf <- data.frame(importance(rf_model)) %>%
  rownames_to_column(., var = "factors") %>%
  data.table() %>%
  setnames(., c("MeanDecreaseAccuracy", "MeanDecreaseGini"), 
           c("Accuracy", "Gini")) %>%
  melt(., measure.vars = c("Accuracy", "Gini")) %>%
  .[variable == "Accuracy"] %>%
  ggplot(., aes(reorder(factors, value), value)) +
  geom_point() +
  coord_flip() +
  scale_y_continuous(breaks = breaks_pretty(n = 3)) +
  labs(x = "", y = "Decrease accuracy") +
  theme_AP()

plot.rf
```

```{r plot_random_forest, dependson="random_forest", fig.height=2.2, fig.width=5.7}

# MULTIWAY IMPORTANCE PLOT ######################################################

plot.multiway <- ggplot(data, aes(x = mean_min_depth, y = times_a_root)) + 
  geom_point(data = data_for_labels, aes(size = no_of_nodes)) + 
  geom_label_repel(data = data_for_labels, aes(label = variable), 
                   show.legend = FALSE, size = 2) + 
  scale_size_continuous(breaks = c(min(data$no_of_nodes), 
                                   median(data$no_of_nodes), 
                                   max(data$no_of_nodes)), 
                        label = label_number(accuracy = 10000)) +
  theme_AP() +
  theme(legend.position = "none")

plot.multiway

# # INTERACTIONS PLOT ##########################################################

# Redefine facet labels --------------------------------------------------------

supp.labs <- c("Decrease", "Increase", "Unstable")
names(supp.labs) <- paste("probability_", supp.labs, sep = "")

# Plot -------------------------------------------------------------------------

plot.predict1 <- plot_predict_interaction(rf_model, df, "interval", "rolling_window_factor") + 
  theme_AP() +
  scale_fill_gradientn(colours = c("white", wes_palette("Zissou1")), 
                       name = "probability", 
                       breaks = c(0, 0.5, 1)) +
  theme(plot.title = element_blank()) +
  labs(x = "Interval", y = "Rolling window factor") +
  scale_x_continuous(breaks = pretty_breaks(n = 3)) +
  facet_grid(~variable,  labeller = labeller(variable = supp.labs)) + 
  theme(legend.position = "none", 
        axis.text.x = element_text(size = 6.1))

plot.predict1

# Now on different combinations

plot.predict2 <- plot_predict_interaction(rf_model, df, "target_year", "interval") + 
  theme_AP() +
  scale_fill_gradientn(colours = c("white", wes_palette("Zissou1")), 
                       name = "probability", 
                       breaks = c(0, 0.5, 1)) +
  theme(plot.title = element_blank()) +
  labs(x = "Target year", y = "Interval") +
  scale_x_continuous(breaks = pretty_breaks(n = 3)) +
  facet_grid(~variable,  labeller = labeller(variable = supp.labs)) + 
  theme(legend.position = "none", 
        axis.text.x = element_text(size = 6.1))

# MERGE RANDOM FOREST PLOTS ####################################################

legend <- get_legend_fun(plot.predict1 + theme(legend.position = "top"))
bottom <- plot_grid(plot.multiway, plot.predict1, ncol = 2, rel_widths = c(0.36, 0.64),
                    labels = "auto")
plot_grid(legend, bottom, rel_heights = c(0.13, 0.87), ncol = 1)
```

```{r plot_multi, dependson="plot_random_forest", fig.height=3.5, fig.width=4.5}

bottom <- plot_grid(plot.predict1, plot.predict2, ncol = 1, labels = "auto")
plot_grid(legend, bottom, rel_heights = c(0.1, 0.9), ncol = 1)
```

```{r merge_rf, fig.height=2, fig.width=4.5}
##
plotp1 <- plot_grid(legend, plot.predict2, ncol = 1, rel_heights = c(0.15, 0.85))
plotp1
```

```{r tree_plot}

library(rpart)
library(rpart.plot)

# Fit a decision tree model-
tree_model <- rpart(trend ~ target_year + target_year_interval + interval
                    + rolling_window_factor + metric, 
                    data = final.dt, method = "class")

# Plot the tree
# Fit a decision tree model
tree_model <- rpart(trend ~ target_year + target_year_interval + interval +
                      rolling_window_factor + metric, 
                    data = final.dt, method = "class")

heat.tree <- function(tree, low.is.green = FALSE, ...) { # dots args passed to prp
  y <- tree$frame$yval
  cols <- ifelse(y == 1, "darkgreen", ifelse(y == 2, "red", "orange"))
  prp(tree, branch.col = cols, box.col = cols, ...)
}

heat.tree(tree_model, type = 2, extra = 100, gap = 0, fallen.leaves = FALSE, 
           tweak = 1.4, clip.right.labs = FALSE)

```


```{r faceted_plot3, dependson = c("plot_naomi", "merge_fraction_rf", "random_forest", "forking_paths", "plot_results_forking_paths", "examples_plots", "plot.models", "plot_examples", "histogram_data_points"), fig.height=6.5, fig.width=5.5}

left <- plot_grid(cumulative.iww, plot.bar, ncol = 1, labels = c("b", "c"))
bottom <- plot_grid(left, plot.models, ncol = 2, labels = c("", "d"), rel_widths = c(0.4, 0.6))
bottom.right <- plot_grid(bottom, plot.examples.trends.data, ncol = 2, rel_widths = c(0.7, 0.3))
plot_grid(plot.iww, bottom.right, ncol = 1, rel_heights = c(0.5, 0.5), labels = c("a", ""))
```

```{r faceted_plot4, dependson = c("plot_naomi", "merge_fraction_rf", "random_forest", "forking_paths", "plot_results_forking_paths", "examples_plots", "plot.models", "plot_examples", "histogram_data_points"), fig.height=6.5, fig.width=6}

# MERGE SA ######################################################################

plot.examples.trends.data <-plot_grid(p1, p2, p3, ncol = 1)
left <- plot_grid(cumulative.iww, plot.bar, ncol = 1, labels = c("b", "c"))
forking.paths <- plot_grid(one.path, all.paths, ncol = 1)
bottom <- plot_grid(left, plot.models, forking.paths, ncol = 3, labels = c("", "d", "e"), 
                    rel_widths = c(0.33, 0.4, 0.26))
bottom.right <- plot_grid(bottom, plot.examples.trends.data, ncol = 2, rel_widths = c(0.8, 0.2), 
                          labels = c("", "f"))
plot_grid(plot.iww, bottom.right, ncol = 1, rel_heights = c(0.5, 0.5), labels = c("a", ""))
```

```{r faceted_plot, dependson="naomi_arrange", fig.height=3.6, fig.width=5.5}

# SENSITIVITY ANALYSIS PLOT BY FACET ############################################

plot.sa.facet <- final.dt %>%
  melt(., measure.vars = c("target_year", "target_year_interval", "interval", 
                          "rolling_window_factor", "metric")) %>%
  .[, .N, .(variable, value, trend)] %>%
  .[ , value := gsub("_normalized", "_n", value)] %>%
  .[variable == "rolling_window_factor", value:= ifelse(value == 1, "0%", "50%")] %>%
  ggplot(., aes(value, N, fill = trend)) +
  scale_fill_manual(values = selected_colors, name = "Uncertainty") +
  geom_bar(stat = "identity", position = position_dodge(0.5)) +
  facet_wrap(~variable, scale = "free", ncol = 1) +
  labs(x = "", y = "Nº simulations") +
  scale_y_continuous(breaks = breaks_pretty(n = 3)) +
  theme_AP() + 
  coord_flip() +
  theme(legend.position = "none", 
        axis.text.y = element_text(size = 5.5), 
        plot.margin = unit(c(0.05, 0, 0, 0.05), "cm"))

plot.sa.facet
```

```{r merge_sa3, dependson=c("merge_sa", "examples_plots", "faceted_plot"), fig.height=6.1, fig.width=5.5}

# MERGE SENSITIVITY ANALYSIS PLOTS #############################################

legend <- get_legend_fun(plot.fraction + theme(legend.position = "top"))
top <- plot_grid(plot.fraction + theme(legend.position = "none"), plot.multiway, ncol = 2, 
                 rel_widths = c(0.4, 0.6), labels = c("b", "c"))
top.with.legend <- plot_grid(legend, top, rel_heights = c(0.1, 0.9), ncol = 1)

left <- plot_grid(plots.examples.trends, top.with.legend, ncol = 1,  
          rel_heights = c(0.75, 0.25))
plot_grid(left, plot.sa.facet, ncol = 2, rel_widths = c(0.67, 0.33), 
          labels = c("a", "d"))

```

```{r check_metric_effect, dependson=c("forking_paths", "naomi_arrange"), fig.height=2.2, fig.width=5.5, warning=FALSE}

# CHECK METRIC EFFECT ###########################################################

data.dt <- lapply(trend, function(x) x[["data"]]) %>%
  rbindlist(., idcol = "row") %>%
  .[order(publication_period)] %>%
  .[publication_period == "2020-2029", publication_period:= "2020-2025"] 
  
# Plot trends based on metric 1 ------------------------------------------------

row.id <- 4

final.dt[row %in% seq(row.id, nrow(forking_paths), 60)]
tmp <-  data.dt[row == row.id] %>%
  merge(., final.dt, by = "row")
metrics <- c("cv", "sd", "entropy")

results <- lapply(metrics, function(m) 
   tmp %>%
      .[, calculate_uncertainty_fun(data = .SD, metric = m), .(publication_period, period_midpoint)] %>%
      .[order(publication_period)] %>%
      .[!V1 == 0] %>%
     .[, trend:= lapply(.SD, check_order_fun), .SDcols = "V1"] %>%
      .[, publication_period:= gsub("–", "-", publication_period)] %>%
     .[publication_period == "2020-2029", publication_period:= "2020-2025"] 
  )

names(results) <- metrics

data.trend <- lapply(results, function(x) 
  x[, scaled:= scale_to_range_fun(data = .SD, column = "V1", 
                                  ref_data = tmp, ref_column = "value")]) %>%
  lapply(., data.table) %>%
  rbindlist(., idcol = "metric") 

p1 <- tmp %>%
  .[!is.na(publication_period)] %>%
  .[, publication_period:= gsub("–", "-", publication_period)] %>%
  .[publication_period == "2020-2029", publication_period:= "2020-2025"] %>%
  ggplot(., aes(publication_period, value)) +
  geom_point(size = 0.3) + 
  geom_line(data = data.trend, aes(x = publication_period, 
                                   y = scaled, lty = metric, group = metric, 
                                   color = trend),
            linewidth = 0.5) +  
  scale_color_manual(values = c("Increase" = "red", "Decrease" = "darkgreen", 
                                "Unstable" = "orange")) +
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  theme_AP() +
  labs(x = "", y = bquote("Km"^3), linetype = NULL) +
  theme(axis.text.x = element_text(size = 6.3), 
        axis.text.y = element_text(size = 6.3),
        axis.title.y = element_text(size = 6.5),
        plot.margin = unit(c(0.05, 0.05, 0, 0.05), "cm"), 
        legend.position = "top") + 
  annotate("text", x = 0.1 + 0.5, y = max(tmp$value), 
           label = unique(tmp$target_year), hjust = 0, vjust = 1, 
           size = 2)

p.withoutline <- tmp %>%
  .[!is.na(publication_period)] %>%
  ggplot(., aes(publication_period, value)) +
  geom_point(size = 0.3) + 
  geom_line(data = data.trend, aes(x = publication_period, 
                                   y = scaled, group = metric, 
                                   color = trend),
            linewidth = 0.5) +  
  scale_color_manual(values = c("Increase" = "red", "Decrease" = "darkgreen", 
                                "Unstable" = "orange"), 
                     name = "Uncertainty") +
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  theme_AP() +
  labs(x = "", y = bquote("Km"^3), linetype = NULL) +
  theme(axis.text.x = element_text(size = 6.3), 
        axis.text.y = element_text(size = 6.3),
        axis.title.y = element_text(size = 6.5),
        plot.margin = unit(c(0.05, 0.05, 0, 0.05), "cm")) + 
  annotate("text", x = 0.1 + 0.5, y = max(tmp$value), 
           label = unique(tmp$target_year), hjust = 0, vjust = 1, 
           size = 2)


# Plot trends based on metric 2 ------------------------------------------------

row.id <- 7

final.dt[row %in% seq(row.id, nrow(forking_paths), 60)]
tmp <-  data.dt[row == row.id] %>%
  merge(., final.dt, by = "row")
metrics <- c("range", "cv", "sd")

results <- lapply(metrics, function(m) 
  tmp %>%
    .[, calculate_uncertainty_fun(data = .SD, metric = m), .(publication_period, period_midpoint)] %>%
    .[order(publication_period)] %>%
    .[!V1 == 0] %>%
    .[, trend:= lapply(.SD, check_order_fun), .SDcols = "V1"] %>%
    .[, publication_period:= gsub("–", "-", publication_period)] %>%
    .[publication_period == "2020-2029", publication_period:= "2020-2025"] 
)


names(results) <- metrics

data.trend <- lapply(results, function(x) 
  x[, scaled:= scale_to_range_fun(data = .SD, column = "V1", ref_data = tmp, 
                                  ref_column = "value")]) %>%
  lapply(., data.table) %>%
  rbindlist(., idcol = "metric") 

p2 <- tmp %>%
  .[!is.na(publication_period)] %>%
  .[, publication_period:= gsub("–", "-", publication_period)] %>%
  .[publication_period == "2020-2029", publication_period:= "2020-2025"] %>%
  ggplot(., aes(publication_period, value)) +
  geom_point(size = 0.3) + 
  geom_line(data = data.trend, aes(x = publication_period, 
                                   y = scaled, color = trend, 
                                   group = metric, lty = metric),
            linewidth = 0.5) +  
  scale_color_manual(values = c("Increase" = "red", "Decrease" = "darkgreen", 
                                "Unstable" = "orange")) +
  guides(color = "none") +
  labs(x = "", y = "", linetype = NULL) +
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  theme_AP() +
  theme(axis.text.x = element_text(size = 6.3), 
        axis.text.y = element_text(size = 6.3),
        axis.title.y = element_text(size = 6.5),
        plot.margin = unit(c(0.05, 0.05, 0, 0.05), "cm"), 
        legend.position = "top") + 
  annotate("text", x = 0.1 + 0.5, y = max(tmp$value), 
           label = unique(tmp$target_year), hjust = 0, vjust = 1, 
           size = 2)

# plot trends based on metrics 3 -----------------------------------------------

row.id <- 40

final.dt[row %in% seq(row.id, nrow(forking_paths), 60)]
tmp <-  data.dt[row == row.id] %>%
  merge(., final.dt, by = "row")
metrics <- c("range", "var", "iqr")

results <- lapply(metrics, function(m) 
  tmp %>%
    .[, calculate_uncertainty_fun(data = .SD, metric = m), .(publication_period, period_midpoint)] %>%
    .[order(publication_period)] %>%
    .[!V1 == 0] %>%
    .[, trend:= lapply(.SD, check_order_fun), .SDcols = "V1"] %>%
    .[, publication_period:= gsub("–", "-", publication_period)] %>%
    .[publication_period == "2020-2029", publication_period:= "2020-2025"]
)


names(results) <- metrics

data.trend <- lapply(results, function(x) 
  x[, scaled:= scale_to_range_fun(data = .SD, column = "V1", ref_data = tmp, 
                                  ref_column = "value")]) %>%
  lapply(., data.table) %>%
  rbindlist(., idcol = "metric") 
  

p3 <- tmp %>%
  .[!is.na(publication_period)] %>%
  .[, publication_period:= gsub("–", "-", publication_period)] %>%
  .[publication_period == "2020-2029", publication_period:= "2020-2025"] %>%
  ggplot(., aes(publication_period, value)) +
  geom_point(size = 0.3) + 
  geom_line(data = data.trend, aes(x = publication_period, 
                                   y = scaled, color = trend, 
                                   group = metric, lty = metric),
            linewidth = 0.5) +  
  scale_color_manual(values = c("Increase" = "red", "Decrease" = "darkgreen", 
                                "Unstable" = "orange")) +
  guides(color = "none") +
  labs(x = "", y = "", linetype = NULL) +
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  theme_AP() +
  theme(axis.text.x = element_text(size = 6.3), 
        axis.text.y = element_text(size = 6.3),
        axis.title.y = element_text(size = 6.5),
        plot.margin = unit(c(0.05, 0.05, 0, 0.05), "cm"), 
        legend.position = "top") + 
  annotate("text", x = 0.1 + 0.5, y = max(tmp$value), 
           label = unique(tmp$target_year), hjust = 0, vjust = 1, 
           size = 2)

da <- get_legend_fun(p.withoutline + theme(legend.position = "top"))
di <- plot_grid(p1 + guides(color = "none"), p2,p3, ncol = 3, labels = "auto")
plot_grid(da, di, rel_heights = c(0.1, 0.9), ncol = 1)
```

\newpage

# Session information

```{r session_information}

# SESSION INFORMATION ##########################################################

sessionInfo()

## Return the machine CPU ------------------------------------------------------

cat("Machine:     "); print(get_cpu()$model_name)

## Return number of true cores -------------------------------------------------

cat("Num cores:   "); print(detectCores(logical = FALSE))

## Return number of threads ---------------------------------------------------

cat("Num threads: "); print(detectCores(logical = FALSE))
```